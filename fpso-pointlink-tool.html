<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PointLink RF Bearing Tool</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@300;400;600;700;900&display=swap');

  :root {
    /* Background & structure */
    --bg:          #06090f;
    --panel:       #0b1018;
    --panel2:      #0f1620;
    --border:      #1c2e42;
    --border2:     #243a52;

    /* Primary accent â€” bright sky blue for compass/headings */
    --accent:      #38b6ff;
    --accent-dim:  rgba(56,182,255,0.15);
    --accent-glow: rgba(56,182,255,0.35);

    /* Signal source â€” vivid amber, max contrast */
    --signal:      #ffb300;
    --signal-dim:  rgba(255,179,0,0.15);
    --signal-glow: rgba(255,179,0,0.4);

    /* Antenna / beam â€” lime green */
    --beam:        #39e87a;
    --beam-dim:    rgba(57,232,122,0.12);
    --beam-glow:   rgba(57,232,122,0.35);

    /* Directional labels */
    --bow-col:     #ff5252;   /* red  â€” BOW */
    --stbd-col:    #39e87a;   /* green â€” STBD */
    --port-col:    #ff5252;   /* red  â€” PORT (convention) */
    --stern-col:   #38b6ff;   /* blue â€” STERN */

    /* Text */
    --text:        #ddeeff;
    --text-dim:    #7a9bb5;
    --muted:       #3d5a72;

    /* Vessel hull colors */
    --hull-dark:   #122035;
    --hull-mid:    #1a3050;
    --hull-light:  #224068;
    --hull-stroke: #38b6ff;

    /* RIG accent */
    --rig-col:     #ffb300;
    --warn:        #ffb300;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
  }

  /* Scanline overlay */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(56,182,255,0.012) 2px,
      rgba(56,182,255,0.012) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  header {
    padding: 14px 28px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(56,182,255,0.04);
  }

  .logo {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 900;
    font-size: 1.4rem;
    letter-spacing: 3px;
    color: var(--accent);
    text-transform: uppercase;
  }

  .logo span { color: var(--signal); }

  .status-bar {
    display: flex;
    gap: 20px;
    font-size: 0.7rem;
    color: var(--text-dim);
  }

  .status-item { display: flex; align-items: center; gap: 6px; }
  .status-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--beam);
    box-shadow: 0 0 6px var(--beam);
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .main {
    display: grid;
    grid-template-columns: 280px 1fr 280px;
    gap: 0;
    flex: 1;
    min-height: calc(100vh - 56px);
  }

  .panel {
    background: var(--panel);
    border-right: 1px solid var(--border);
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .panel:last-child {
    border-right: none;
    border-left: 1px solid var(--border);
  }

  .section-title {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 700;
    font-size: 0.72rem;
    letter-spacing: 3px;
    color: var(--text-dim);
    text-transform: uppercase;
    border-bottom: 1px solid var(--border);
    padding-bottom: 8px;
  }

  .input-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .input-label {
    font-size: 0.68rem;
    color: var(--text-dim);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .input-row {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(56,182,255,0.05);
    border: 1px solid var(--border2);
    border-radius: 4px;
    padding: 0 10px;
    transition: border-color 0.2s;
  }

  .input-row:focus-within {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-dim);
  }

  .input-row input {
    background: none;
    border: none;
    outline: none;
    color: #ffffff;
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.25rem;
    width: 100%;
    padding: 8px 0;
  }

  .input-row .unit {
    color: var(--text-dim);
    font-size: 0.8rem;
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    height: 4px;
    background: var(--border2);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent);
    border-radius: 50%;
    box-shadow: 0 0 8px var(--accent-glow);
    cursor: pointer;
  }

  /* Heading input uses blue, signal input uses amber */
  .input-row.heading input { color: var(--accent); }
  .input-row.signal  input { color: var(--signal); }

  .big-value {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 900;
    font-size: 3.4rem;
    color: var(--accent);
    line-height: 1;
    text-align: center;
    text-shadow: 0 0 24px var(--accent-glow);
  }

  .big-value.amber { color: var(--signal); text-shadow: 0 0 24px var(--signal-glow); }
  .big-value.green { color: var(--beam);   text-shadow: 0 0 24px var(--beam-glow); }

  .big-label {
    font-size: 0.64rem;
    letter-spacing: 2px;
    color: var(--text-dim);
    text-align: center;
    text-transform: uppercase;
    margin-top: 3px;
  }

  /* Result cards */
  .result-card {
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--border2);
    border-radius: 6px;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    position: relative;
    overflow: hidden;
    transition: background 0.2s, border-color 0.2s;
  }

  .result-card::before {
    content: '';
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 3px;
    background: var(--accent);
  }

  .result-card.amber::before  { background: var(--signal); }
  .result-card.green::before  { background: var(--beam); }
  .result-card.yellow::before { background: var(--warn); }

  .result-card:hover {
    background: rgba(255,255,255,0.05);
    border-color: var(--border2);
  }

  .card-title {
    font-size: 0.66rem;
    color: var(--text-dim);
    letter-spacing: 1.5px;
    text-transform: uppercase;
  }

  .card-value {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 700;
    font-size: 1.8rem;
    color: var(--accent);
  }

  .card-value.amber  { color: var(--signal); }
  .card-value.green  { color: var(--beam); }
  .card-value.yellow { color: var(--warn); }

  .card-sub {
    font-size: 0.63rem;
    color: var(--text-dim);
    line-height: 1.4;
  }

  /* Antenna list */
  .antenna-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
    overflow-y: auto;
  }

  .antenna-item {
    background: rgba(255,255,255,0.025);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    position: relative;
  }

  .antenna-item .ant-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .ant-name {
    font-size: 0.8rem;
    color: var(--beam);
    letter-spacing: 1px;
  }

  .ant-bearing {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 700;
    font-size: 1.1rem;
  }

  .ant-controls {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .ant-controls input[type=number] {
    background: rgba(56,182,255,0.05);
    border: 1px solid var(--border2);
    color: #ffffff;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem;
    padding: 4px 8px;
    border-radius: 3px;
    width: 60px;
    outline: none;
    text-align: center;
  }

  .ant-label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 1px;
  }

  .btn {
    background: none;
    border: 1px solid var(--border2);
    color: var(--text-dim);
    cursor: pointer;
    padding: 4px 10px;
    border-radius: 3px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.72rem;
    transition: all 0.2s;
    letter-spacing: 1px;
  }

  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.danger:hover { border-color: #ff5252; color: #ff5252; }
  .btn.primary {
    background: var(--beam-dim);
    border-color: var(--beam);
    color: var(--beam);
  }

  .btn-add {
    width: 100%;
    padding: 10px;
    text-align: center;
    font-size: 0.75rem;
    letter-spacing: 2px;
  }

  /* Center canvas area */
  .canvas-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    padding: 20px;
    position: relative;
    background: radial-gradient(ellipse at center, #0a1520 0%, var(--bg) 68%);
  }

  .compass-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas { display: block; }

  .compass-info {
    display: flex;
    gap: 24px;
    font-size: 0.68rem;
  }

  .info-item {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-dim);
  }

  .info-dot { width: 10px; height: 10px; border-radius: 2px; }

  .tooltip {
    position: absolute;
    background: #0b1018;
    border: 1px solid var(--accent);
    border-radius: 4px;
    padding: 8px 12px;
    font-size: 0.72rem;
    pointer-events: none;
    white-space: nowrap;
    z-index: 50;
    display: none;
    box-shadow: 0 0 20px var(--accent-glow);
  }

  .tooltip .t-val {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--accent);
  }

  /* bearing indicator strip */
  .bearing-strip {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    padding: 0 20px;
  }

  .strip-item {
    text-align: center;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 4px;
  }

  .strip-label { font-size: 0.58rem; color: var(--text-dim); letter-spacing: 1px; text-transform: uppercase; line-height: 1.3; }
  .strip-value { font-family: 'Barlow Condensed', sans-serif; font-weight: 700; font-size: 1.35rem; }

  hr.divider {
    border: none;
    border-top: 1px solid var(--border);
    margin: 2px 0;
  }

  /* Vessel type selector */
  .vessel-selector {
    display: flex;
    gap: 0;
    border: 1px solid var(--border2);
    border-radius: 5px;
    overflow: hidden;
  }

  .vessel-type-btn {
    flex: 1;
    padding: 9px 6px;
    background: none;
    border: none;
    color: var(--text-dim);
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 700;
    font-size: 0.85rem;
    letter-spacing: 2px;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    border-right: 1px solid var(--border);
  }

  .vessel-type-btn:last-child { border-right: none; }

  .vessel-type-btn.active {
    background: var(--accent-dim);
    color: var(--accent);
    box-shadow: inset 0 -2px 0 var(--accent);
  }

  .vessel-type-btn:hover:not(.active) {
    background: rgba(255,255,255,0.04);
    color: var(--text);
  }

  .vessel-type-btn.rig.active {
    background: var(--signal-dim);
    color: var(--signal);
    box-shadow: inset 0 -2px 0 var(--signal);
  }

  .vessel-badge {
    display: inline-block;
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 700;
    font-size: 0.65rem;
    letter-spacing: 2px;
    padding: 2px 7px;
    border-radius: 3px;
    margin-left: 8px;
    vertical-align: middle;
  }

  .vessel-badge.fpso { background: var(--accent-dim); color: var(--accent); }
  .vessel-badge.rig  { background: var(--signal-dim); color: var(--signal); }

  .vessel-info-box {
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 10px 12px;
    font-size: 0.68rem;
    color: var(--text-dim);
    line-height: 1.65;
  }

  .vessel-info-box strong { color: var(--text); }

  .color-swatch {
    display: inline-block;
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 4px;
    vertical-align: middle;
  }
</style>
</head>
<body>

<header>
  <div class="logo"><span id="headerVesselType">FPSO</span> <span>PointLink</span> RF BEARING TOOL</div>
  <div class="status-bar">
    <div class="status-item"><div class="status-dot"></div><span>LIVE</span></div>
    <div class="status-item" id="vesselModeBadge"><span class="vessel-badge fpso">FPSO</span></div>
    <div class="status-item">DYNAMIC COMPASS</div>
    <div class="status-item" id="clock">--:--:-- UTC</div>
  </div>
</header>

<div class="main">
  <!-- LEFT PANEL -->
  <div class="panel">
    <div class="section-title">Vessel Type</div>

    <div class="vessel-selector">
      <button class="vessel-type-btn active" id="btnFPSO" onclick="setVesselType('FPSO')">â›´ FPSO</button>
      <button class="vessel-type-btn rig"    id="btnRIG"  onclick="setVesselType('RIG')">ğŸ— RIG / SEMISUB</button>
    </div>

    <div class="vessel-info-box" id="vesselInfoBox">
      <strong>FPSO</strong> â€” Floating Production, Storage &amp; Offloading.<br>
      Has a <strong>bow</strong> and is subject to weathervaning. Heading changes with wind/current â€” update True Heading frequently.
    </div>

    <hr class="divider">
    <div class="section-title">Vessel Configuration</div>

    <div class="input-group">
      <div class="input-label" id="headingConfigLabel">True Heading (Â°)</div>
      <div class="input-row heading">
        <input type="number" id="trueHeading" min="0" max="359" value="045" placeholder="000-359">
        <span class="unit">Â°T</span>
      </div>
      <input type="range" id="headingSlider" min="0" max="359" value="45">
    </div>

    <div style="text-align:center;">
      <div class="big-value" id="headingDisplay">045Â°</div>
      <div class="big-label">True Heading</div>
    </div>

    <hr class="divider">
    <div class="section-title">RF Signal Source</div>

    <div class="input-group">
      <div class="input-label">Signal Source True Bearing (Â°)</div>
      <div class="input-row signal">
        <input type="number" id="signalBearing" min="0" max="359" value="090" placeholder="000-359">
        <span class="unit">Â°T</span>
      </div>
      <input type="range" id="signalSlider" min="0" max="359" value="90">
    </div>

    <div style="text-align:center;">
      <div class="big-value amber" id="signalDisplay">090Â°</div>
      <div class="big-label">Signal True Bearing</div>
    </div>

    <hr class="divider">

    <div class="result-card amber">
      <div class="card-title">Relative Bearing to Signal</div>
      <div class="card-value amber" id="relBearing">045Â°</div>
      <div class="card-sub" id="relBearingSub">Measured from vessel's BOW (000Â°R)</div>
    </div>

    <div class="result-card">
      <div class="card-title">Signal from</div>
      <div class="card-value" id="signalSector">STARBOARD BOW</div>
      <div class="card-sub" id="signalSectorSub">045Â° â†’ 135Â° relative</div>
    </div>
  </div>

  <!-- CENTER: CANVAS -->
  <div class="canvas-area">
    <div class="compass-container">
      <canvas id="compassCanvas" width="520" height="520"></canvas>
      <div class="tooltip" id="tooltip">
        <div class="t-val" id="tooltipVal">---Â°</div>
        <div id="tooltipLabel">True Bearing</div>
      </div>
    </div>

    <div class="bearing-strip" id="bearingStrip">
      <div class="strip-item">
        <div class="strip-label">â¬† BOW / 000Â°R</div>
        <div class="strip-value" id="bowBearing" style="color:#ff5252">---Â°T</div>
      </div>
      <div class="strip-item">
        <div class="strip-label">â¬Œ STBD / 090Â°R</div>
        <div class="strip-value" id="stbdBearing" style="color:#39e87a">---Â°T</div>
      </div>
      <div class="strip-item">
        <div class="strip-label">â¬‡ STERN / 180Â°R</div>
        <div class="strip-value" id="sternBearing" style="color:#38b6ff">---Â°T</div>
      </div>
      <div class="strip-item">
        <div class="strip-label">â¬Œ PORT / 270Â°R</div>
        <div class="strip-value" id="portBearing" style="color:#ff5252">---Â°T</div>
      </div>
    </div>

    <div class="compass-info">
      <div class="info-item"><div class="info-dot" style="background:#38b6ff;border-radius:50%"></div>Vessel / Heading</div>
      <div class="info-item"><div class="info-dot" style="background:#ffb300;border-radius:50%"></div>RF Signal</div>
      <div class="info-item"><div class="info-dot" style="background:#39e87a;border-radius:50%"></div>Antenna Beam</div>
    </div>
  </div>

  <!-- RIGHT PANEL: ANTENNAS -->
  <div class="panel">
    <div class="section-title">Antennas / PointLink</div>

    <div class="antenna-list" id="antennaList"></div>

    <button class="btn primary btn-add" onclick="addAntenna()">+ ADD ANTENNA</button>

    <hr class="divider">
    <div class="section-title">Results</div>

    <div class="result-card green">
      <div class="card-title">PointLink Required Bearing</div>
      <div class="card-value green" id="plRequired">---Â°</div>
      <div class="card-sub" id="plSub">Point antenna to this true bearing to acquire signal</div>
    </div>

    <div class="result-card" id="coverageCard">
      <div class="card-title">Active Antenna Coverage</div>
      <div class="card-value" id="coverageVal">---</div>
      <div class="card-sub" id="coverageSub">Based on selected antenna</div>
    </div>

    <div style="font-size:0.65rem; color:var(--text-dim); line-height:1.65; margin-top:4px; background:rgba(255,255,255,0.03); border:1px solid var(--border); border-radius:4px; padding:10px 12px;" id="tipBox">
      ğŸ’¡ <strong style="color:var(--accent);">TIP:</strong> Set vessel True Heading + RF Signal True Bearing. 
      The Relative Bearing shows where the signal comes from relative to the bow. 
      Point your PointLink to the <strong style="color:var(--beam);">green bearing</strong>.
    </div>
  </div>
</div>

<script>
// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let heading = 45;       // vessel true heading
let signalBrg = 90;     // signal true bearing
let vesselType = 'FPSO'; // 'FPSO' | 'RIG'
let antennas = [
  { id: 1, name: 'PointLink-A', offset: 0,   beamWidth: 30, active: true },
  { id: 2, name: 'PointLink-B', offset: 180, beamWidth: 30, active: false },
];
let nextId = 3;
let dragging = null;    // 'heading' | 'signal' | antennaId

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const norm = d => ((d % 360) + 360) % 360;
const toRad = d => d * Math.PI / 180;

function dirLabel(relBrg) {
  const r = norm(relBrg);
  if (r < 11.25 || r >= 348.75) return 'AHEAD (BOW)';
  if (r < 33.75)  return 'FINE STBD BOW';
  if (r < 56.25)  return 'STBD BOW';
  if (r < 78.75)  return 'BROAD STBD BOW';
  if (r < 101.25) return 'STARBOARD';
  if (r < 123.75) return 'BROAD STBD QUARTER';
  if (r < 146.25) return 'STBD QUARTER';
  if (r < 168.75) return 'FINE STBD QUARTER';
  if (r < 191.25) return 'ASTERN (STERN)';
  if (r < 213.75) return 'FINE PORT QUARTER';
  if (r < 236.25) return 'PORT QUARTER';
  if (r < 258.75) return 'BROAD PORT QUARTER';
  if (r < 281.25) return 'PORT';
  if (r < 303.75) return 'BROAD PORT BOW';
  if (r < 326.25) return 'PORT BOW';
  return 'FINE PORT BOW';
}

// â”€â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('compassCanvas');
const ctx = canvas.getContext('2d');
const CX = canvas.width / 2;
const CY = canvas.height / 2;
const OUTER_R = 230;
const INNER_R = 190;
const VESSEL_L = 100;   // longer hull
const VESSEL_W = 28;

function bearingToXY(brg, r) {
  const a = toRad(brg - 90);
  return { x: CX + r * Math.cos(a), y: CY + r * Math.sin(a) };
}

function drawCompass() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // â”€â”€ Background glow
  const bgGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, OUTER_R);
  bgGrad.addColorStop(0, 'rgba(0,40,80,0.5)');
  bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = bgGrad;
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R + 10, 0, Math.PI * 2);
  ctx.fill();

  // â”€â”€ Outer ring
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(0,212,255,0.25)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // â”€â”€ Inner ring
  ctx.beginPath();
  ctx.arc(CX, CY, INNER_R, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(0,212,255,0.12)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // â”€â”€ Degree ticks + labels
  for (let d = 0; d < 360; d++) {
    const isMajor   = d % 10 === 0;
    const isMedium  = d % 5 === 0 && !isMajor;
    const a = toRad(d - 90);
    const r1 = isMajor ? OUTER_R - 16 : (isMedium ? OUTER_R - 10 : OUTER_R - 5);
    const r2 = OUTER_R;
    ctx.beginPath();
    ctx.moveTo(CX + r1 * Math.cos(a), CY + r1 * Math.sin(a));
    ctx.lineTo(CX + r2 * Math.cos(a), CY + r2 * Math.sin(a));
    ctx.strokeStyle = isMajor ? 'rgba(0,212,255,0.6)' : 'rgba(0,212,255,0.25)';
    ctx.lineWidth = isMajor ? 1.5 : 0.8;
    ctx.stroke();

    if (isMajor) {
      const lr = OUTER_R - 28;
      const lx = CX + lr * Math.cos(a);
      const ly = CY + lr * Math.sin(a);
      ctx.save();
      ctx.translate(lx, ly);
      ctx.rotate(a + Math.PI / 2);
      ctx.font = d % 30 === 0 ? 'bold 11px Barlow Condensed' : '9px Barlow Condensed';
      ctx.fillStyle = d % 30 === 0 ? 'rgba(0,212,255,0.9)' : 'rgba(0,212,255,0.5)';
      ctx.textAlign = 'center';
      ctx.fillText(d, 0, 0);
      ctx.restore();
    }
  }

  // â”€â”€ Cardinal labels (outside)
  const cardinals = [
    { d: 0,   lbl: 'N', col: '#ffffff' },
    { d: 90,  lbl: 'E', col: 'rgba(0,212,255,0.7)' },
    { d: 180, lbl: 'S', col: 'rgba(0,212,255,0.7)' },
    { d: 270, lbl: 'W', col: 'rgba(0,212,255,0.7)' },
  ];
  cardinals.forEach(({ d, lbl, col }) => {
    const a = toRad(d - 90);
    const r = OUTER_R + 18;
    ctx.font = 'bold 16px Barlow Condensed';
    ctx.fillStyle = col;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lbl, CX + r * Math.cos(a), CY + r * Math.sin(a));
  });

  // â”€â”€ True North indicator (fixed)
  ctx.save();
  ctx.beginPath();
  const na = toRad(-90);
  const nr = OUTER_R - 5;
  ctx.moveTo(CX + nr * Math.cos(na), CY + nr * Math.sin(na));
  ctx.lineTo(CX + (OUTER_R + 8) * Math.cos(na), CY + (OUTER_R + 8) * Math.sin(na));
  ctx.strokeStyle = '#4488ff';
  ctx.lineWidth = 2.5;
  ctx.stroke();
  ctx.restore();

  // â”€â”€ Signal beam cone
  const relBrg = norm(signalBrg - heading);
  const absSignalAngle = toRad(signalBrg - 90);

  // Draw beam line from center to signal
  ctx.beginPath();
  ctx.moveTo(CX, CY);
  const sp = bearingToXY(signalBrg, INNER_R - 10);
  ctx.lineTo(sp.x, sp.y);
  ctx.strokeStyle = 'rgba(255,107,0,0.6)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Signal source marker
  const sm = bearingToXY(signalBrg, OUTER_R - 2);
  ctx.beginPath();
  ctx.arc(sm.x, sm.y, 8, 0, Math.PI * 2);
  const sg = ctx.createRadialGradient(sm.x, sm.y, 0, sm.x, sm.y, 8);
  sg.addColorStop(0, 'rgba(255,107,0,1)');
  sg.addColorStop(1, 'rgba(255,107,0,0)');
  ctx.fillStyle = sg;
  ctx.fill();
  ctx.beginPath();
  ctx.arc(sm.x, sm.y, 8, 0, Math.PI * 2);
  ctx.strokeStyle = '#ff6b00';
  ctx.lineWidth = 2;
  ctx.stroke();

  // â”€â”€ Antenna beams (behind vessel)
  antennas.forEach(ant => {
    const trueBrg = norm(heading + ant.offset);
    const halfBeam = ant.beamWidth / 2;
    const a1 = toRad(trueBrg - halfBeam - 90);
    const a2 = toRad(trueBrg + halfBeam - 90);

    // beam fill
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.arc(CX, CY, INNER_R - 15, a1, a2);
    ctx.closePath();
    const inSignal = isInBeam(trueBrg, signalBrg, ant.beamWidth);
    ctx.fillStyle = inSignal
      ? 'rgba(255,204,0,0.15)'
      : 'rgba(255,204,0,0.05)';
    ctx.fill();
    ctx.strokeStyle = inSignal ? 'rgba(255,204,0,0.5)' : 'rgba(255,204,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // center line
    const tp = bearingToXY(trueBrg, INNER_R - 15);
    ctx.beginPath();
    ctx.moveTo(CX, CY);
    ctx.lineTo(tp.x, tp.y);
    ctx.strokeStyle = inSignal ? '#ffcc00' : 'rgba(255,204,0,0.4)';
    ctx.lineWidth = inSignal ? 2 : 1;
    ctx.setLineDash([4, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // label
    const lp = bearingToXY(trueBrg, INNER_R + 18);
    ctx.font = '10px Share Tech Mono';
    ctx.fillStyle = inSignal ? '#ffcc00' : 'rgba(255,204,0,0.5)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ant.name.split('-').pop() || ant.name, lp.x, lp.y);
  });

  // â”€â”€ FPSO / RIG Vessel shape (rotated by heading)
  ctx.save();
  ctx.translate(CX, CY);
  ctx.rotate(toRad(heading));

  ctx.shadowColor = 'rgba(0,212,255,0.3)';
  ctx.shadowBlur = 18;

  if (vesselType === 'FPSO') {
    // â”€â”€ FPSO: long ship hull with pointed bow
    const BW = VESSEL_W;       // half-width
    const BL = VESSEL_L;       // half-length (bow tip to center)
    const SL = VESSEL_L * 0.7; // stern distance from center

    ctx.beginPath();
    ctx.moveTo(0, -BL);                          // bow tip
    ctx.bezierCurveTo( BW, -BL + 12,  BW,  -20,  BW * 0.75,  SL * 0.85);
    ctx.lineTo( BW * 0.4, SL);                  // stern transom STBD
    ctx.lineTo(-BW * 0.4, SL);                  // stern transom PORT
    ctx.bezierCurveTo(-BW * 0.75, SL * 0.85, -BW, -20, -BW, -BL + 12);
    ctx.closePath();

    const hullGrad = ctx.createLinearGradient(-BW, 0, BW, 0);
    hullGrad.addColorStop(0,   '#162f50');
    hullGrad.addColorStop(0.35,'#1f4872');
    hullGrad.addColorStop(0.5, '#2a5c88');
    hullGrad.addColorStop(0.65,'#1f4872');
    hullGrad.addColorStop(1,   '#162f50');
    ctx.fillStyle = hullGrad;
    ctx.fill();
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Waterline stripe
    ctx.save();
    ctx.clip();
    ctx.fillStyle = 'rgba(0,212,255,0.07)';
    ctx.fillRect(-BW, SL * 0.5, BW * 2, SL * 0.4);
    ctx.restore();

    // Main deck block (superstructure aft)
    ctx.fillStyle = 'rgba(0,212,255,0.13)';
    ctx.fillRect(-BW * 0.55, SL * 0.05, BW * 1.1, SL * 0.55);

    // Forward module
    ctx.fillStyle = 'rgba(0,212,255,0.1)';
    ctx.fillRect(-BW * 0.4, -BL * 0.55, BW * 0.8, BL * 0.4);

    // Flare tower / mast at bow area
    ctx.fillStyle = 'rgba(0,212,255,0.25)';
    ctx.fillRect(-3, -BL + 18, 6, 20);
    ctx.fillRect(-1.5, -BL + 10, 3, 10);
    // Flare boom
    ctx.beginPath();
    ctx.moveTo(0, -BL + 18);
    ctx.lineTo(12, -BL + 28);
    ctx.strokeStyle = 'rgba(0,212,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Helideck (circle aft)
    ctx.beginPath();
    ctx.arc(0, SL * 0.3, 12, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,212,255,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-6, SL * 0.3);
    ctx.lineTo(6, SL * 0.3);
    ctx.moveTo(0, SL * 0.3 - 6);
    ctx.lineTo(0, SL * 0.3 + 6);
    ctx.stroke();

    // Longitudinal deck lines
    for (let i = -1; i <= 1; i++) {
      ctx.beginPath();
      ctx.moveTo(i * (BW * 0.45), -BL * 0.5);
      ctx.lineTo(i * (BW * 0.45),  SL * 0.75);
      ctx.strokeStyle = 'rgba(0,212,255,0.08)';
      ctx.lineWidth = 0.8;
      ctx.stroke();
    }

    // Side mooring bollards
    for (let y = -BL * 0.3; y < SL * 0.6; y += BL * 0.25) {
      ctx.beginPath();
      ctx.arc( BW * 0.9, y, 2.5, 0, Math.PI * 2);
      ctx.arc(-BW * 0.9, y, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,212,255,0.18)';
      ctx.fill();
    }

    // Labels
    ctx.font = 'bold 11px Barlow Condensed';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff4444';
    ctx.fillText('BOW', 0, -BL - 14);
    ctx.fillStyle = '#4488ff';
    ctx.fillText('STERN', 0, SL + 14);
    ctx.fillStyle = '#00cc66';
    ctx.fillText('STBD', BW + 14, 0);
    ctx.fillStyle = '#ff6688';
    ctx.fillText('PORT', -BW - 14, 0);

    // Bow triangle
    ctx.beginPath();
    ctx.moveTo(0, -BL - 4);
    ctx.lineTo(-5, -BL + 8);
    ctx.lineTo( 5, -BL + 8);
    ctx.closePath();
    ctx.fillStyle = '#ff4444';
    ctx.fill();

  } else {
    // â”€â”€ RIG / SEMI-SUBMERSIBLE: boxy platform shape
    const RW = VESSEL_W * 1.6;  // rig half-width (wider, squarer)
    const RL = VESSEL_W * 1.4;  // rig half-length

    // Draw pontoons (bottom floats - two rectangles port and stbd)
    const pontoonW = RW * 0.38;
    const pontoonH = RL * 2;
    const pontoonY = -RL;
    const pontoonX = RW * 0.55;

    // STBD pontoon
    ctx.beginPath();
    ctx.roundRect(pontoonX - pontoonW / 2, pontoonY, pontoonW, pontoonH, 4);
    ctx.fillStyle = '#1a3a5f';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,212,255,0.6)';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    // PORT pontoon
    ctx.beginPath();
    ctx.roundRect(-pontoonX - pontoonW / 2, pontoonY, pontoonW, pontoonH, 4);
    ctx.fillStyle = '#1a3a5f';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,212,255,0.6)';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    ctx.shadowBlur = 0;

    // Cross-braces between pontoons (fore and aft)
    const braceH = RL * 0.35;
    [-RL * 0.55, RL * 0.55].forEach(by => {
      ctx.beginPath();
      ctx.roundRect(-pontoonX + pontoonW / 2, by - braceH / 2, pontoonX * 2 - pontoonW, braceH, 3);
      ctx.fillStyle = '#16325a';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,212,255,0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    });

    // Main deck / work platform
    const deckW = RW * 1.1;
    const deckH = RL * 1.6;
    ctx.beginPath();
    ctx.roundRect(-deckW / 2, -deckH / 2, deckW, deckH, 5);
    const deckGrad = ctx.createLinearGradient(-deckW / 2, 0, deckW / 2, 0);
    deckGrad.addColorStop(0,   '#162f50');
    deckGrad.addColorStop(0.5, '#214566');
    deckGrad.addColorStop(1,   '#162f50');
    ctx.fillStyle = deckGrad;
    ctx.fill();
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Derrick / drill tower (center prominent feature)
    ctx.fillStyle = 'rgba(255,204,0,0.25)';
    ctx.fillRect(-5, -RL * 0.6, 10, RL * 1.2);
    ctx.strokeStyle = 'rgba(255,204,0,0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(-5, -RL * 0.6, 10, RL * 1.2);
    // Derrick top chevron
    ctx.beginPath();
    ctx.moveTo(0, -RL * 0.6 - 14);
    ctx.lineTo(-5, -RL * 0.6);
    ctx.lineTo( 5, -RL * 0.6);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,204,0,0.5)';
    ctx.fill();

    // Crane arm
    ctx.beginPath();
    ctx.moveTo(deckW * 0.35, -RL * 0.1);
    ctx.lineTo(deckW * 0.35 + 18, -RL * 0.5);
    ctx.strokeStyle = 'rgba(0,212,255,0.35)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Deck detail grid
    for (let gx = -deckW * 0.4; gx <= deckW * 0.4; gx += deckW * 0.22) {
      ctx.beginPath();
      ctx.moveTo(gx, -deckH / 2 + 4);
      ctx.lineTo(gx,  deckH / 2 - 4);
      ctx.strokeStyle = 'rgba(0,212,255,0.07)';
      ctx.lineWidth = 0.7;
      ctx.stroke();
    }
    for (let gy = -deckH * 0.4; gy <= deckH * 0.4; gy += deckH * 0.25) {
      ctx.beginPath();
      ctx.moveTo(-deckW / 2 + 4, gy);
      ctx.lineTo( deckW / 2 - 4, gy);
      ctx.strokeStyle = 'rgba(0,212,255,0.07)';
      ctx.lineWidth = 0.7;
      ctx.stroke();
    }

    // Anchor legs (spider pattern, 4 corners)
    [[-RW * 0.85, -RL * 0.8], [RW * 0.85, -RL * 0.8],
     [-RW * 0.85,  RL * 0.8], [RW * 0.85,  RL * 0.8]].forEach(([ax, ay]) => {
      ctx.beginPath();
      ctx.moveTo(ax * 0.6, ay * 0.6);
      ctx.lineTo(ax, ay);
      ctx.strokeStyle = 'rgba(0,212,255,0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.arc(ax, ay, 3, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,212,255,0.3)';
      ctx.fill();
    });

    // Leg columns (4 corner columns - semisub style)
    [[-RW * 0.5, -RL * 0.45], [RW * 0.5, -RL * 0.45],
     [-RW * 0.5,  RL * 0.45], [RW * 0.5,  RL * 0.45]].forEach(([lx, ly]) => {
      ctx.beginPath();
      ctx.arc(lx, ly, 6, 0, Math.PI * 2);
      ctx.fillStyle = '#1c3f65';
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,212,255,0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
    });

    // North reference arrow on rig (since heading matters less visually, show "N" reference)
    ctx.font = 'bold 10px Barlow Condensed';
    ctx.fillStyle = 'rgba(255,204,0,0.8)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('REF', 0, -RL * 0.82);

    // Labels
    ctx.font = 'bold 11px Barlow Condensed';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff4444';
    ctx.fillText('NORTH REF', 0, -RL * 1.1 - 14);
    ctx.fillStyle = '#4488ff';
    ctx.fillText('SOUTH REF', 0, RL * 1.1 + 14);
    ctx.fillStyle = '#00cc66';
    ctx.fillText('EAST REF', RW + 16, 0);
    ctx.fillStyle = '#ff6688';
    ctx.fillText('WEST REF', -RW - 16, 0);

    // North arrow
    ctx.beginPath();
    ctx.moveTo(0, -RL * 1.1 - 4);
    ctx.lineTo(-5, -RL * 1.1 + 8);
    ctx.lineTo( 5, -RL * 1.1 + 8);
    ctx.closePath();
    ctx.fillStyle = '#ff4444';
    ctx.fill();
  }

  ctx.restore();

  // â”€â”€ Heading arrow
  const hwp = bearingToXY(heading, OUTER_R - 5);
  ctx.save();
  ctx.shadowColor = '#00d4ff';
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.moveTo(CX, CY);
  ctx.lineTo(hwp.x, hwp.y);
  ctx.strokeStyle = 'rgba(0,212,255,0.5)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // â”€â”€ Center dot
  ctx.beginPath();
  ctx.arc(CX, CY, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#00d4ff';
  ctx.fill();

  // â”€â”€ Relative bearing arc (vessel-relative)
  if (relBrg !== 0) {
    const arcStart = toRad(heading - 90);       // bow direction
    const arcEnd = toRad(signalBrg - 90);
    const arcR = 60;
    ctx.beginPath();
    // always draw shorter arc
    const diff = norm(signalBrg - heading);
    const goClockwise = diff < 180;
    ctx.arc(CX, CY, arcR, arcStart, arcEnd, !goClockwise);
    ctx.strokeStyle = 'rgba(255,107,0,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // arc label
    const midBrg = heading + (goClockwise ? diff / 2 : diff / 2 + 180);
    const mp = bearingToXY(norm(midBrg), arcR + 16);
    ctx.font = 'bold 11px Barlow Condensed';
    ctx.fillStyle = '#ff6b00';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(Math.round(relBrg) + 'Â°R', mp.x, mp.y);
  }
}

function isInBeam(antTrueBrg, sigTrueBrg, beamWidth) {
  const diff = Math.abs(norm(sigTrueBrg - antTrueBrg));
  return diff <= beamWidth / 2 || diff >= 360 - beamWidth / 2;
}

// â”€â”€â”€ Vessel Type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setVesselType(type) {
  vesselType = type;

  // Update buttons
  document.getElementById('btnFPSO').classList.toggle('active', type === 'FPSO');
  document.getElementById('btnRIG').classList.toggle('active',  type === 'RIG');

  // Update header badge
  const badge = document.getElementById('vesselModeBadge');
  badge.innerHTML = type === 'FPSO'
    ? '<span class="vessel-badge fpso">FPSO</span>'
    : '<span class="vessel-badge rig">RIG / SEMISUB</span>';

  // Update header title
  document.getElementById('headerVesselType').textContent = type === 'FPSO' ? 'FPSO' : 'RIG';

  // Update info box
  const info = document.getElementById('vesselInfoBox');
  if (type === 'FPSO') {
    info.innerHTML = `<strong>FPSO</strong> â€” Floating Production, Storage &amp; Offloading.<br>
      Has a <strong>bow</strong> and is subject to weathervaning. Heading changes with wind/current â€” update True Heading frequently.`;
  } else {
    info.innerHTML = `<strong>RIG / SEMISUB</strong> â€” Drilling rig or semi-submersible.<br>
      No fixed bow â€” uses a <strong>grid reference</strong>. Rigs drift and rotate on mooring lines. 
      <em>Use 000Â° as your reference north axis.</em> Recompute antenna bearings after any rotation.`;
  }

  // Update bearing strip labels
  if (type === 'FPSO') {
    document.querySelector('#bowBearing').previousElementSibling.textContent   = 'â¬† BOW / 000Â°R';
    document.querySelector('#stbdBearing').previousElementSibling.textContent  = 'â¬Œ STBD / 090Â°R';
    document.querySelector('#sternBearing').previousElementSibling.textContent = 'â¬‡ STERN / 180Â°R';
    document.querySelector('#portBearing').previousElementSibling.textContent  = 'â¬Œ PORT / 270Â°R';
  } else {
    document.querySelector('#bowBearing').previousElementSibling.textContent   = 'â¬† N-REF / 000Â°R';
    document.querySelector('#stbdBearing').previousElementSibling.textContent  = 'â¬Œ E-REF / 090Â°R';
    document.querySelector('#sternBearing').previousElementSibling.textContent = 'â¬‡ S-REF / 180Â°R';
    document.querySelector('#portBearing').previousElementSibling.textContent  = 'â¬Œ W-REF / 270Â°R';
  }

  // Update heading label
  const headingLabel = document.getElementById('headingConfigLabel');
  if (headingLabel) {
    headingLabel.textContent = type === 'FPSO' ? 'True Heading (Â°)' : 'Rig Orientation / Rotation (Â°)';
  }

  update();
}

// â”€â”€â”€ Update UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  heading   = norm(parseInt(document.getElementById('trueHeading').value)  || 0);
  signalBrg = norm(parseInt(document.getElementById('signalBearing').value) || 0);

  // Sync sliders
  document.getElementById('headingSlider').value = heading;
  document.getElementById('signalSlider').value  = signalBrg;

  document.getElementById('headingDisplay').textContent = pad(heading) + 'Â°';
  document.getElementById('signalDisplay').textContent  = pad(signalBrg) + 'Â°';

  // Update heading label context
  const bigLabel = document.querySelector('#headingDisplay + .big-label');
  if (bigLabel) bigLabel.textContent = vesselType === 'FPSO' ? 'True Heading' : 'Rig Orientation';

  const rel = norm(signalBrg - heading);
  document.getElementById('relBearing').textContent = pad(rel) + 'Â°R';
  document.getElementById('relBearingSub').textContent = vesselType === 'FPSO'
    ? `Measured from vessel's BOW (000Â°R)`
    : `Measured from rig reference axis (000Â°R)`;
  document.getElementById('signalSector').textContent = dirLabel(rel);
  document.getElementById('signalSectorSub').textContent = vesselType === 'FPSO'
    ? `Relative bearing: ${pad(rel)}Â°`
    : `From rig reference axis: ${pad(rel)}Â°`;

  // Bow / STBD / Stern / Port true bearings
  document.getElementById('bowBearing').textContent   = pad(norm(heading))       + 'Â°T';
  document.getElementById('stbdBearing').textContent  = pad(norm(heading + 90))  + 'Â°T';
  document.getElementById('sternBearing').textContent = pad(norm(heading + 180)) + 'Â°T';
  document.getElementById('portBearing').textContent  = pad(norm(heading + 270)) + 'Â°T';

  // PointLink required: point the PointLink at signal source true bearing
  document.getElementById('plRequired').textContent = pad(signalBrg) + 'Â°T';

  // Update tip based on vessel type
  const tipBox = document.getElementById('tipBox');
  if (tipBox) {
    tipBox.innerHTML = vesselType === 'FPSO'
      ? `ğŸ’¡ <strong style="color:var(--accent);">TIP:</strong> Set vessel True Heading + RF Signal True Bearing. 
         The Relative Bearing shows where the signal comes from relative to vessel bow. 
         Point your PointLink to the <span style="color:var(--accent3);">Required True Bearing</span>.`
      : `ğŸ’¡ <strong style="color:var(--warn);">RIG TIP:</strong> Rigs rotate on mooring lines. Enter the rig's current rotation angle + RF signal bearing. 
         Recheck antenna bearings after <em>any</em> rig rotation â€” even 5Â° matters for PointLink. 
         Required true bearing shown in <span style="color:var(--accent3);">green</span>.`;
  }

  // Coverage check for active antenna
  const active = antennas.find(a => a.active);
  if (active) {
    const trueBrg = norm(heading + active.offset);
    const inBeam  = isInBeam(trueBrg, signalBrg, active.beamWidth);
    document.getElementById('coverageVal').textContent = inBeam ? 'âœ“ IN BEAM' : 'âœ— OUT OF BEAM';
    document.getElementById('coverageVal').style.color = inBeam ? 'var(--accent3)' : '#ff4444';
    document.getElementById('coverageSub').textContent =
      `${active.name} â†’ ${pad(trueBrg)}Â°T | Beam Â±${active.beamWidth/2}Â°`;
  } else {
    document.getElementById('coverageVal').textContent = 'NO ACTIVE ANT';
    document.getElementById('coverageSub').textContent = 'Select an antenna above';
  }

  renderAntennaList();
  drawCompass();
}

function pad(n) {
  return String(Math.round(norm(n))).padStart(3, '0');
}

// â”€â”€â”€ Antenna List â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderAntennaList() {
  const list = document.getElementById('antennaList');
  list.innerHTML = '';
  antennas.forEach(ant => {
    const trueBrg = norm(heading + ant.offset);
    const inBeam  = isInBeam(trueBrg, signalBrg, ant.beamWidth);
    const relOff  = norm(ant.offset);

    const el = document.createElement('div');
    el.className = 'antenna-item';
    el.innerHTML = `
      <div class="ant-header">
        <div class="ant-name" style="color:${ant.active?'var(--accent)':'var(--muted)'}">${ant.name}</div>
        <div class="ant-bearing" style="color:${inBeam?'var(--accent3)':'var(--muted)'}">${pad(trueBrg)}Â°T</div>
      </div>
      <div class="ant-label">Rel offset: ${pad(relOff)}Â°R | Beam: Â±${ant.beamWidth/2}Â° | ${inBeam?'âœ“ IN BEAM':'âœ— OUT'}</div>
      <div class="ant-controls">
        <div style="display:flex;flex-direction:column;gap:2px;">
          <div class="ant-label">Offset (Â°R)</div>
          <input type="number" value="${relOff}" min="0" max="359" 
            onchange="updateAntenna(${ant.id},'offset',this.value)"
            title="Relative offset from bow">
        </div>
        <div style="display:flex;flex-direction:column;gap:2px;">
          <div class="ant-label">Beam (Â°)</div>
          <input type="number" value="${ant.beamWidth}" min="5" max="360" step="5"
            onchange="updateAntenna(${ant.id},'beamWidth',this.value)"
            title="Total beam width">
        </div>
        <button class="btn ${ant.active?'primary':''}" onclick="toggleActive(${ant.id})">${ant.active?'ACTIVE':'SELECT'}</button>
        <button class="btn danger" onclick="removeAntenna(${ant.id})">âœ•</button>
      </div>
    `;
    list.appendChild(el);
  });
}

function updateAntenna(id, field, val) {
  const ant = antennas.find(a => a.id === id);
  if (!ant) return;
  ant[field] = field === 'offset' ? norm(parseFloat(val)) : parseFloat(val);
  update();
}

function toggleActive(id) {
  antennas.forEach(a => a.active = a.id === id);
  update();
}

function removeAntenna(id) {
  antennas = antennas.filter(a => a.id !== id);
  if (!antennas.some(a => a.active) && antennas.length > 0) antennas[0].active = true;
  update();
}

function addAntenna() {
  const name = `PointLink-${String.fromCharCode(64 + nextId)}`;
  antennas.push({ id: nextId++, name, offset: 0, beamWidth: 30, active: false });
  update();
}

// â”€â”€â”€ Event Listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('trueHeading').addEventListener('input', update);
document.getElementById('signalBearing').addEventListener('input', update);
document.getElementById('headingSlider').addEventListener('input', function () {
  document.getElementById('trueHeading').value = this.value;
  update();
});
document.getElementById('signalSlider').addEventListener('input', function () {
  document.getElementById('signalBearing').value = this.value;
  update();
});

// â”€â”€â”€ Canvas mouse drag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getAngleFromCanvas(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX - CX;
  const my = (e.clientY - rect.top)  * scaleY - CY;
  const angle = Math.atan2(my, mx) * 180 / Math.PI + 90;
  return norm(angle);
}

function isNearBearing(brg, mouseAngle, threshold = 12) {
  const diff = Math.abs(norm(mouseAngle - brg));
  return diff < threshold || diff > 360 - threshold;
}

canvas.addEventListener('mousedown', (e) => {
  const a = getAngleFromCanvas(e);
  if (isNearBearing(heading, a)) {
    dragging = 'heading';
  } else if (isNearBearing(signalBrg, a)) {
    dragging = 'signal';
  } else {
    // check antennas
    for (const ant of antennas) {
      const trueBrg = norm(heading + ant.offset);
      if (isNearBearing(trueBrg, a)) {
        dragging = 'ant_' + ant.id;
        break;
      }
    }
  }
  canvas.style.cursor = dragging ? 'grabbing' : 'default';
});

canvas.addEventListener('mousemove', (e) => {
  const a = getAngleFromCanvas(e);
  const tt = document.getElementById('tooltip');
  const rect = canvas.getBoundingClientRect();

  if (dragging === 'heading') {
    heading = Math.round(a);
    document.getElementById('trueHeading').value = heading;
    update();
  } else if (dragging === 'signal') {
    signalBrg = Math.round(a);
    document.getElementById('signalBearing').value = signalBrg;
    update();
  } else if (dragging && dragging.startsWith('ant_')) {
    const id = parseInt(dragging.split('_')[1]);
    const ant = antennas.find(x => x.id === id);
    if (ant) {
      ant.offset = norm(Math.round(a) - heading);
      update();
    }
  }

  // Tooltip
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mx = (e.clientX - rect.left) * scaleX - CX;
  const my = (e.clientY - rect.top)  * scaleY - CY;
  const dist = Math.sqrt(mx * mx + my * my);
  if (dist > INNER_R - 20 && dist < OUTER_R + 20) {
    tt.style.display = 'block';
    tt.style.left = (e.clientX - rect.left + 14) + 'px';
    tt.style.top  = (e.clientY - rect.top - 40) + 'px';
    document.getElementById('tooltipVal').textContent = pad(a) + 'Â°T';
    document.getElementById('tooltipLabel').textContent = 'True Bearing';
  } else {
    tt.style.display = 'none';
  }

  // cursor
  const nearSomething = isNearBearing(heading, a) || isNearBearing(signalBrg, a) ||
    antennas.some(ant => isNearBearing(norm(heading + ant.offset), a));
  canvas.style.cursor = dragging ? 'grabbing' : (nearSomething ? 'grab' : 'crosshair');
});

canvas.addEventListener('mouseup', () => {
  dragging = null;
  canvas.style.cursor = 'crosshair';
});
canvas.addEventListener('mouseleave', () => {
  dragging = null;
  document.getElementById('tooltip').style.display = 'none';
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  const fake = { clientX: t.clientX, clientY: t.clientY };
  canvas.dispatchEvent(new MouseEvent('mousedown', fake));
});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  const fake = { clientX: t.clientX, clientY: t.clientY };
  canvas.dispatchEvent(new MouseEvent('mousemove', fake));
});
canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  canvas.dispatchEvent(new MouseEvent('mouseup', {}));
});

// â”€â”€â”€ Clock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateClock() {
  const now = new Date();
  const h = String(now.getUTCHours()).padStart(2,'0');
  const m = String(now.getUTCMinutes()).padStart(2,'0');
  const s = String(now.getUTCSeconds()).padStart(2,'0');
  document.getElementById('clock').textContent = `${h}:${m}:${s} UTC`;
}
setInterval(updateClock, 1000);
updateClock();

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
update();
</script>
</body>
</html>
